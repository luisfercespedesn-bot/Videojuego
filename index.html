<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mario 3D Studio: Pro Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111827; color: white; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(31, 41, 55, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.6);
            width: 280px;
            border: 1px solid #4b5563;
            max-height: 85vh;
            overflow-y: auto;
        }
        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #ef4444;
            color: white;
            font-weight: bold;
            pointer-events: none;
            display: flex;
            gap: 15px;
            font-family: 'Courier New', Courier, monospace;
            z-index: 20;
        }
        /* Mobile Controls */
        #touchControls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            z-index: 50;
        }
        .joystick-area {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        #joystickKnob {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 70px);
            gap: 15px;
            pointer-events: auto;
        }
        .touch-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
            color: white;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.5); }
        
        #gameOver {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .coord-input {
            background: #374151;
            border: 1px solid #4b5563;
            color: white;
            border-radius: 4px;
            padding: 2px 5px;
            width: 60px;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="gameOver">
        <h1 class="text-6xl font-black text-red-600 mb-4">GAME OVER</h1>
        <button onclick="location.reload()" class="bg-white text-black px-6 py-2 rounded-full font-bold hover:bg-gray-200 transition">REINTENTAR</button>
    </div>

    <div class="stats-panel">
        <div> <span id="scoreVal">0</span></div>
        <div>わ <span id="livesVal">3</span></div>
    </div>

    <!-- Controles T谩ctiles -->
    <div id="touchControls">
        <div class="joystick-area" id="joystickZone">
            <div id="joystickKnob"></div>
        </div>
        <div class="action-buttons">
            <div class="touch-btn bg-red-500/40" id="btnJump" title="Saltar">A</div>
            <div class="touch-btn bg-blue-500/40" id="btnAction" title="Acci贸n">B</div>
            <div class="touch-btn bg-yellow-500/40" id="btnPower" title="Taladro">S</div>
            <div class="touch-btn bg-white/20" id="btnFly" title="Volar">W</div>
        </div>
    </div>

    <div class="ui-panel">
        <h2 class="text-xl font-black mb-3 text-yellow-400 flex items-center gap-2">
            <span></span> Editor de Mario
        </h2>
        
        <div class="space-y-4">
            <div>
                <label class="text-[10px] font-bold text-gray-400 uppercase">Seleccionar Objeto</label>
                <select id="entityType" class="w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white text-sm outline-none">
                    <option value="mario">Mario (Jugador)</option>
                    <option value="block">Bloque S贸lido</option>
                    <option value="platform">Plataforma M贸vil</option>
                    <option value="goomba">Goomba</option>
                    <option value="piranha">Planta Pira帽a</option>
                    <option value="fireplant">Pira帽a de Fuego</option>
                    <option value="flower">Flor de Fuego</option>
                    <option value="iceflower">Flor de Hielo</option>
                    <option value="boomerangflower">Flor Boomerang</option>
                    <option value="wingcap">Gorra Alada</option>
                    <option value="drill">Taladro</option>
                    <option value="mushroom">Champi帽贸n</option>
                    <option value="coin">Moneda</option>
                    <option value="pipe">Tuber铆a</option>
                </select>
            </div>

            <div>
                <label class="text-[10px] font-bold text-gray-400 uppercase mb-1 block">Coordenadas de Aparici贸n</label>
                <div class="flex gap-2 items-center">
                    <span class="text-xs text-gray-500">X:</span>
                    <input type="number" id="posX" value="0" class="coord-input">
                    <span class="text-xs text-gray-500">Y:</span>
                    <input type="number" id="posY" value="0" class="coord-input">
                    <span class="text-xs text-gray-500">Z:</span>
                    <input type="number" id="posZ" value="0" class="coord-input">
                </div>
            </div>

            <button onclick="spawnFromCoords()" class="w-full bg-yellow-500 hover:bg-yellow-400 text-black font-black py-2 rounded shadow-lg text-sm transition">
                COLOCAR OBJETO
            </button>

            <div class="pt-2 border-t border-gray-700">
                <button onclick="resetScene()" class="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-1 rounded text-[10px] uppercase tracking-wider">
                    LIMPIAR ESCENA
                </button>
            </div>
            
            <div class="text-[9px] text-gray-500 leading-tight">
                Controles: Flechas o Joystick para mover.<br>
                Espacio/A: Saltar | F/B: Disparar<br>
                S: Taladro (si tienes) | W: Volar (si tienes)
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls, dragControls;
        let objects = [], enemies = [], fireballs = [], iceballs = [], boomerangs = [], platforms = [], solidBlocks = [];
        let playableMario = null;
        let score = 0, lives = 3;
        let isWarping = false, isSuper = false, isFire = false, isIce = false, isWing = false, isDrill = false, isDrilling = false, isBoomerang = false, isInvulnerable = false;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if (type === 'jump') { osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
            else if (type === 'hit') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3); gain.gain.setValueAtTime(0.2, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.3); }
            else if (type === 'fire') { osc.type = 'triangle'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
            else if (type === 'coin') { osc.type = 'sine'; osc.frequency.setValueAtTime(987, audioCtx.currentTime); osc.frequency.setValueAtTime(1318, audioCtx.currentTime + 0.08); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.3); }
            else if (type === 'drill') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.2); gain.gain.setValueAtTime(0.05, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
            else if (type === 'boomerang') { osc.type = 'sine'; osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
        }

        const moveState = { forward: 0, back: 0, left: 0, right: 0, jumping: false, flying: 0, vX: 0, vY: 0, vZ: 0 };
        const GRAVITY = -0.018, JUMP_FORCE = 0.42, FLY_FORCE = 0.035, ACCEL_GROUND = 0.04, FRICTION_GROUND = 0.85, MAP_LIMIT = 48;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5c94fc); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 1); sun.position.set(10, 30, 10); sun.castShadow = true; scene.add(sun);
            scene.add(new THREE.GridHelper(100, 100, 0x000000, 0x444444));
            setupInteractions();
            setupTouchControls();
            animate();
        }

        function setupInteractions() {
            dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
            dragControls.addEventListener('dragstart', () => controls.enabled = false);
            dragControls.addEventListener('dragend', () => controls.enabled = true);
            window.addEventListener('keydown', (e) => {
                if (isWarping || lives <= 0 || !playableMario) return;
                switch(e.code) {
                    case 'ArrowUp': moveState.forward = 1; break;
                    case 'ArrowDown': moveState.back = 1; break;
                    case 'ArrowLeft': moveState.left = 1; break;
                    case 'ArrowRight': moveState.right = 1; break;
                    case 'KeyW': if(isWing) moveState.flying = 1; break;
                    case 'KeyS': if(isDrill) toggleDrill(); break;
                    case 'Space': handleJump(); break;
                    case 'KeyF': handleAction(); break;
                }
            });
            window.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'ArrowUp': moveState.forward = 0; break;
                    case 'ArrowDown': moveState.back = 0; break;
                    case 'ArrowLeft': moveState.left = 0; break;
                    case 'ArrowRight': moveState.right = 0; break;
                    case 'KeyW': moveState.flying = 0; break;
                }
            });
        }

        function setupTouchControls() {
            const joystick = document.getElementById('joystickZone');
            const knob = document.getElementById('joystickKnob');
            let rect, centerX, centerY;

            function updateJoystickMetrics() {
                rect = joystick.getBoundingClientRect();
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
                const angle = Math.atan2(dy, dx);
                
                knob.style.left = `calc(50% + ${Math.cos(angle) * dist}px)`;
                knob.style.top = `calc(50% + ${Math.sin(angle) * dist}px)`;

                // Umbral para activar movimiento
                moveState.right = dx > 15 ? 1 : 0;
                moveState.left = dx < -15 ? 1 : 0;
                moveState.forward = dy < -15 ? 1 : 0;
                moveState.back = dy > 15 ? 1 : 0;
            }

            joystick.addEventListener('touchstart', (e) => { updateJoystickMetrics(); handleTouchMove(e); });
            joystick.addEventListener('touchmove', handleTouchMove);
            joystick.addEventListener('touchend', () => {
                knob.style.left = '50%'; knob.style.top = '50%';
                moveState.forward = moveState.back = moveState.left = moveState.right = 0;
            });

            document.getElementById('btnJump').addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); });
            document.getElementById('btnAction').addEventListener('touchstart', (e) => { e.preventDefault(); handleAction(); });
            document.getElementById('btnPower').addEventListener('touchstart', (e) => { e.preventDefault(); if(isDrill) toggleDrill(); });
            document.getElementById('btnFly').addEventListener('touchstart', (e) => { e.preventDefault(); if(isWing) moveState.flying = 1; });
            document.getElementById('btnFly').addEventListener('touchend', (e) => { moveState.flying = 0; });
        }

        function handleJump() {
            if (!playableMario || isWarping) return;
            if (isDrilling) { toggleDrill(); moveState.vY = JUMP_FORCE * 1.2; }
            else if (!moveState.jumping) { moveState.jumping = true; moveState.vY = JUMP_FORCE; playSound('jump'); }
        }

        function handleAction() {
            if (isFire) shootProjectile('fire'); 
            else if (isIce) shootProjectile('ice'); 
            else if (isBoomerang) shootBoomerang();
        }

        function toggleDrill() {
            isDrilling = !isDrilling;
            playSound('drill');
            if (isDrilling) playableMario.position.y -= 1.2;
            else { playableMario.position.y += 1.2; moveState.vY = 0.1; moveState.jumping = true; }
        }

        function resetScene() {
            objects.forEach(o => scene.remove(o)); objects = []; enemies = []; fireballs = []; iceballs = []; boomerangs = []; platforms = []; solidBlocks = [];
            playableMario = null; score = 0; lives = 3; isSuper = isFire = isIce = isWing = isDrill = isDrilling = isBoomerang = false;
            document.getElementById('scoreVal').innerText = "0"; document.getElementById('livesVal').innerText = "3";
        }

        function spawnFromCoords() {
            const type = document.getElementById('entityType').value;
            const x = parseFloat(document.getElementById('posX').value) || 0;
            const y = parseFloat(document.getElementById('posY').value) || 0;
            const z = parseFloat(document.getElementById('posZ').value) || 0;

            let entity;
            switch(type) {
                case 'mario': entity = createMario(x, y, z); playableMario = entity; break;
                case 'block': entity = createSolidBlock(x, y, z); solidBlocks.push(entity); break;
                case 'platform': entity = createMovingPlatform(x, y, z); platforms.push(entity); break;
                case 'goomba': entity = createGoomba(x, y, z); enemies.push(entity); break;
                case 'piranha': entity = createPiranha(x, y, z, false); enemies.push(entity); break;
                case 'fireplant': entity = createPiranha(x, y, z, true); enemies.push(entity); break;
                case 'flower': entity = createPowerup(x, y, z, 0xff4500, 'flower'); break;
                case 'iceflower': entity = createPowerup(x, y, z, 0x00ffff, 'iceflower'); break;
                case 'boomerangflower': entity = createPowerup(x, y, z, 0x3b82f6, 'boomerangflower'); break;
                case 'wingcap': entity = createPowerup(x, y, z, 0xffffff, 'wingcap'); break;
                case 'drill': entity = createPowerup(x, y, z, 0xffd700, 'drill'); break;
                case 'mushroom': entity = createPowerup(x, y, z, 0xff0000, 'mushroom'); break;
                case 'coin': entity = createCoin(x, y, z); break;
                case 'pipe': entity = createPipe(x, y, z); break;
            }
            if(entity) { scene.add(entity); objects.push(entity); }
        }

        function createMario(x, y, z) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.5), new THREE.MeshPhongMaterial({color: 0xff0000}));
            body.position.y = 0.5; body.name = "marioBody";
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshPhongMaterial({color: 0xffcc99}));
            head.position.y = 1.3;
            const hatGroup = new THREE.Group();
            const hat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.8), new THREE.MeshPhongMaterial({color: 0xff0000}));
            hat.name = "marioHat";
            hatGroup.add(hat); hatGroup.position.y = 1.7; hatGroup.name = "hatGroup";

            const drillPart = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), new THREE.MeshPhongMaterial({color: 0xffff00}));
            drillPart.position.y = 0.4; drillPart.visible = false; drillPart.name = "drillMesh";
            hatGroup.add(drillPart);

            const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.1), new THREE.MeshPhongMaterial({color: 0xffffff}));
            wingL.position.set(-0.5, 0.1, 0); wingL.visible = false; wingL.name = "wingL";
            const wingR = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.1), new THREE.MeshPhongMaterial({color: 0xffffff}));
            wingR.position.set(0.5, 0.1, 0); wingR.visible = false; wingR.name = "wingR";
            hatGroup.add(wingL, wingR);

            group.add(body, head, hatGroup); group.position.set(x, y, z); group.isMarioEntity = true; return group;
        }

        function createSolidBlock(x, y, z) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshPhongMaterial({color: 0x8b4513}));
            mesh.position.set(x, y + 1, z); mesh.isMarioEntity = mesh.isSolid = true; return mesh;
        }

        function createMovingPlatform(x, y, z) {
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 0.4, 2), new THREE.MeshPhongMaterial({color: 0xff8c00}));
            group.add(mesh); group.position.set(x, y, z); group.isMarioEntity = group.isPlatform = true;
            group.userData = { initialY: y, speed: 0.02, range: 4, offset: Math.random() * Math.PI * 2 }; return group;
        }

        function updateMarioApperance() {
            if (!playableMario) return;
            let bodyColor = 0xff0000, hatColor = 0xff0000;
            if (isFire) { bodyColor = 0xffffff; hatColor = 0xff0000; }
            if (isIce) { bodyColor = 0xadd8e6; hatColor = 0x0000ff; }
            if (isDrill) { bodyColor = 0xffff00; hatColor = 0x8b4513; }
            if (isBoomerang) { bodyColor = 0x3b82f6; hatColor = 0xffffff; }

            const wL = playableMario.getObjectByName("wingL");
            const wR = playableMario.getObjectByName("wingR");
            const dM = playableMario.getObjectByName("drillMesh");
            if(wL) wL.visible = isWing;
            if(wR) wR.visible = isWing;
            if(dM) dM.visible = isDrill;

            playableMario.children.forEach(c => { if (c.name === "marioBody") c.material.color.setHex(bodyColor); });
            const mainHat = playableMario.getObjectByName("marioHat");
            if(mainHat) mainHat.material.color.setHex(hatColor);
        }

        function createPowerup(x, y, z, color, type) {
            const group = new THREE.Group();
            let geometry = type === 'drill' ? new THREE.ConeGeometry(0.5, 1, 8) : 
                           type === 'boomerangflower' ? new THREE.TorusGeometry(0.4, 0.15, 8, 16) :
                           new THREE.SphereGeometry(0.6, 12, 12);
            const mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({color}));
            group.add(mesh); group.position.set(x, y + 0.5, z); group.isMarioEntity = true; group.userData = { type }; return group;
        }

        function createGoomba(x, y, z) {
            const group = new THREE.Group();
            const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 1), new THREE.MeshPhongMaterial({color: 0x8b4513}));
            head.position.y = 0.7;
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 0.5, 8), new THREE.MeshPhongMaterial({color: 0xf5f5dc}));
            body.position.y = 0.25; group.add(head, body); group.position.set(x, y, z);
            group.isMarioEntity = group.isGoomba = true;
            group.walkDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(); return group;
        }

        function createPiranha(x, y, z, isFirePlant) {
            const group = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), new THREE.MeshPhongMaterial({color: 0x00ff00}));
            stem.position.y = 0.75;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshPhongMaterial({color: isFirePlant ? 0xff4500 : 0xff0000}));
            head.position.y = 1.6; group.add(stem, head); group.position.set(x, y, z);
            group.isMarioEntity = group.isEnemy = true;
            group.userData = { isFirePlant, lastShot: 0 }; return group;
        }

        function createPipe(x, y, z) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 2.5, 20), new THREE.MeshPhongMaterial({color: 0x228b22}));
            const top = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 0.8, 20), new THREE.MeshPhongMaterial({color: 0x228b22}));
            top.position.y = 1.3; group.add(body, top); group.position.set(x, y, z); group.isMarioEntity = true; return group;
        }

        function createCoin(x, y, z) {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16), new THREE.MeshPhongMaterial({color: 0xffd700}));
            mesh.rotation.x = Math.PI/2; mesh.position.set(x, y + 1, z); mesh.isMarioEntity = mesh.isCoin = true; return mesh;
        }

        function shootProjectile(type) {
            if (!playableMario || isDrilling) return;
            playSound('fire');
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), new THREE.MeshPhongMaterial({color: type === 'fire' ? 0xff4500 : 0x00ffff}));
            ball.position.copy(playableMario.position).y += 1;
            const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(playableMario.quaternion).normalize();
            ball.userData = { vel: dir.multiplyScalar(0.45), life: 180, type };
            scene.add(ball);
            if (type === 'fire') fireballs.push(ball); else iceballs.push(ball);
        }

        function shootBoomerang() {
            if (!playableMario || isDrilling || boomerangs.length >= 2) return;
            playSound('boomerang');
            const group = new THREE.Group();
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.2), new THREE.MeshPhongMaterial({color: 0x3b82f6}));
            p1.position.x = 0.3; p1.rotation.z = Math.PI/4;
            const p2 = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.2), new THREE.MeshPhongMaterial({color: 0x3b82f6}));
            p2.position.x = -0.3; p2.rotation.z = -Math.PI/4;
            group.add(p1, p2); group.position.copy(playableMario.position).y += 1;
            const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(playableMario.quaternion).normalize();
            group.userData = { state: 'forward', vel: dir.multiplyScalar(0.35), spawnPos: group.position.clone(), life: 300 };
            scene.add(group); boomerangs.push(group);
        }

        function takeDamage() {
            if (isInvulnerable || lives <= 0 || isDrilling) return;
            if (isFire || isIce || isSuper || isWing || isDrill || isBoomerang) {
                isFire = isIce = isSuper = isWing = isDrill = isDrilling = isBoomerang = false; playableMario.scale.set(1, 1, 1); updateMarioApperance();
                startInvulnerability(); playSound('hit');
            } else {
                lives--; document.getElementById('livesVal').innerText = lives; playSound('hit');
                if (lives <= 0) document.getElementById('gameOver').style.display = 'flex';
                else { moveState.vY = 0.25; moveState.jumping = true; startInvulnerability(); }
            }
        }

        function startInvulnerability() {
            isInvulnerable = true; let f = 0;
            const i = setInterval(() => { if(!playableMario) return; playableMario.visible = !playableMario.visible; f++; if(f>20){ clearInterval(i); playableMario.visible=true; isInvulnerable=false; } }, 100);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();

            if (playableMario && lives > 0) {
                const dM = playableMario.getObjectByName("drillMesh");
                if (dM && isDrill) dM.rotation.y += 0.3;

                let speedMult = isDrilling ? 0.6 : 1.0;
                let ix = (moveState.right - moveState.left) * ACCEL_GROUND * speedMult;
                let iz = (moveState.back - moveState.forward) * ACCEL_GROUND * speedMult;
                moveState.vX = (moveState.vX + ix) * FRICTION_GROUND;
                moveState.vZ = (moveState.vZ + iz) * FRICTION_GROUND;
                playableMario.position.x += moveState.vX; playableMario.position.z += moveState.vZ;

                let onSurface = playableMario.position.y <= 0;
                solidBlocks.forEach(b => {
                    const dx = Math.abs(playableMario.position.x - b.position.x);
                    const dz = Math.abs(playableMario.position.z - b.position.z);
                    const dy = playableMario.position.y - b.position.y;
                    if (dx < 1.4 && dz < 1.4 && !isDrilling && dy >= 0.8 && dy <= 1.2) {
                        onSurface = true; if(!moveState.flying) playableMario.position.y = b.position.y + 1;
                    }
                });

                if(isDrilling) {
                    playableMario.position.y = Math.min(playableMario.position.y, -0.5);
                    playableMario.visible = (now % 200 > 50);
                } else {
                    playableMario.visible = !isInvulnerable || (now % 200 > 100);
                    if(moveState.flying) {
                        moveState.vY = Math.min(moveState.vY + FLY_FORCE, 0.2);
                        playableMario.position.y += moveState.vY; moveState.jumping = true;
                    } else {
                        if (moveState.jumping || !onSurface) {
                            playableMario.position.y += moveState.vY; moveState.vY += GRAVITY;
                            if (playableMario.position.y <= 0) { playableMario.position.y = 0; moveState.jumping = false; moveState.vY = 0; }
                            else if (onSurface && moveState.vY < 0) { moveState.jumping = false; moveState.vY = 0; }
                        }
                    }
                }

                if (Math.abs(moveState.vX) > 0.02 || Math.abs(moveState.vZ) > 0.02) playableMario.rotation.y = Math.atan2(moveState.vX, moveState.vZ);

                objects.forEach(o => {
                    if (o === playableMario || o.isSolid) return;
                    const d = playableMario.position.distanceTo(o.position);
                    if (d < 1.5) {
                        if (o.isCoin) { playSound('coin'); score++; document.getElementById('scoreVal').innerText = score; scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'flower') { isFire = true; isIce = isWing = isDrill = isBoomerang = false; updateMarioApperance(); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'iceflower') { isIce = true; isFire = isWing = isDrill = isBoomerang = false; updateMarioApperance(); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'boomerangflower') { isBoomerang = true; isFire = isIce = isWing = isDrill = false; updateMarioApperance(); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'wingcap') { isWing = true; isFire = isIce = isDrill = isBoomerang = false; updateMarioApperance(); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'drill') { isDrill = true; isFire = isIce = isWing = isBoomerang = false; updateMarioApperance(); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.userData.type === 'mushroom') { isSuper = true; playableMario.scale.set(1.5,1.5,1.5); scene.remove(o); objects = objects.filter(x => x !== o); }
                        else if (o.isGoomba || o.isEnemy) {
                            if (isDrilling) return;
                            if (playableMario.position.y > o.position.y + 0.5 && moveState.vY < 0) {
                                scene.remove(o); enemies = enemies.filter(x => x !== o); objects = objects.filter(x => x !== o);
                                moveState.vY = 0.3; moveState.jumping = true;
                            } else if (!isInvulnerable) takeDamage();
                        }
                    }
                });
            }

            // L贸gica de Boomerangs
            boomerangs.forEach(b => {
                b.rotation.y += 0.5;
                if (b.userData.state === 'forward') {
                    b.position.add(b.userData.vel);
                    if (b.position.distanceTo(b.userData.spawnPos) > 12) b.userData.state = 'returning';
                } else if (playableMario) {
                    const returnDir = new THREE.Vector3().subVectors(playableMario.position, b.position).normalize();
                    b.position.add(returnDir.multiplyScalar(0.4));
                    if (b.position.distanceTo(playableMario.position) < 1) { scene.remove(b); boomerangs = boomerangs.filter(x => x !== b); return; }
                }
                enemies.forEach(e => {
                    if (b.position.distanceTo(e.position) < 1.5) { scene.remove(e); enemies = enemies.filter(x => x !== e); objects = objects.filter(x => x !== e); playSound('hit'); }
                });
                b.userData.life--;
                if (b.userData.life <= 0) { scene.remove(b); boomerangs = boomerangs.filter(x => x !== b); }
            });

            enemies.forEach(e => {
                if (e.isGoomba) {
                    if (playableMario && !isDrilling && playableMario.position.distanceTo(e.position) < 15) {
                        const dir = new THREE.Vector3().subVectors(playableMario.position, e.position);
                        dir.y = 0; e.walkDir.lerp(dir.normalize(), 0.05);
                    }
                    e.position.addScaledVector(e.walkDir, 0.05);
                    e.rotation.y = Math.atan2(e.walkDir.x, e.walkDir.z);
                    if (Math.abs(e.position.x) > MAP_LIMIT || Math.abs(e.position.z) > MAP_LIMIT) e.walkDir.negate();
                }
            });

            fireballs.forEach((b) => {
                b.position.add(b.userData.vel);
                b.userData.life--;
                if (b.userData.life <= 0) { scene.remove(b); fireballs = fireballs.filter(f => f !== b); }
            });

            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        window.onload = init;
    </script>
</body>
</html>
